#lang racket

; garbage-collecting CESIK*Ξ machine for ANF Scheme (lambda if set! let letrec)
; gc on application evaluation
; guarded pop from Ξ with immediate (local) kont application (the halt state is still handled as an administractive step)
; local Ξ

(random-seed 111) ; deterministic random
(define MEMO (lambda (msg) #f))
(define DEBUG '())

(include "../general.rkt")

;; domain helpers
(define (env-lookup ρ x)
  (hash-ref ρ x))
(define (env-addresses ρ)
  (list->set (hash-values ρ)))
(define (store-lookup σ a)
  (hash-ref σ a))
(define (stack-lookup Ξ τ)
  (hash-ref Ξ τ))
(define (ae? e)
  (match e
    ((? symbol? e) #t)
    (`(lambda ,_ ,_) #t)
    ((? boolean? e) #t)
    ((? number? e) #t)
    ((? string? e) #t)
    (`(quote ,e) (not (pair? e)))
    (_ #f)))
(define (free e)
  (define (f e env)
    (match e
      ((? symbol? e) (if (set-member? env e)
                         (set)
                         (set e)))
      (`(lambda ,x ,e) (f e (set-union env (list->set x))))
      (`(let ((,x ,e0)) ,e1) (set-union (f e0 env) (f e1 (set-add env x))))
      (`(letrec ((,x ,e0)) ,e1) (set-union (f e0 (set-add env x)) (f e1 (set-add env x))))
      (`(if ,ae ,e1 ,e2) (set-union (f ae env) (f e1 env) (f e2 env)))
      (`(set! ,x ,ae) (set-union (f x env) (f ae env) ))
      (`(quote ,_) (set))
      (`(,rator . ,rands) (set-union (f rator env) (for/fold ((xs (set))) ((rand rands)) (set-union xs (f rand env)))))
      (_ (set))))
  (f e (set)))
;;

;; machine
(struct machine (⊥ ⊔ inject step answer?) #:transparent)
(struct ev (e ρ σ ι κ Ξ) #:transparent)
(struct ko (ι κ v σ Ξ) #:transparent)
(struct ctx (clo vs σ) #:transparent)
(struct letk (x e ρ) #:transparent)
(struct letreck (a e ρ) #:transparent)
(struct haltk () #:transparent)
(struct clo (λ ρ) #:transparent)
(struct prim (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                        (equal? (prim-name s1) (prim-name s2))))
                                                   (define hash-proc (lambda (s rhash) (equal-hash-code (prim-name s))))
                                                   (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim-name s))))))
(struct prim2 (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                        (equal? (prim2-name s1) (prim2-name s2))))
                                                   (define hash-proc (lambda (s rhash) (equal-hash-code (prim2-name s))))
                                                   (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim2-name s))))))
(struct addr (a) #:transparent)
(struct system (mach states) #:transparent)

(define (make-machine global α γ ⊥ ⊔ alloc true? false? α-eq?)
  (define (env-bind ρ x a)
    (hash-set ρ x a))
  (define (store-alloc σ a v)
    (hash-set σ a (⊔ (hash-ref σ a ⊥) v)))
  (define (store-update σ a v)
    (hash-set σ a (⊔ (hash-ref σ a) v)))
  (define (eval-atom ae ρ σ)
    (match ae
      ((? symbol? ae) (store-lookup σ (env-lookup ρ ae)))
      (`(lambda ,x ,e0) (α (clo ae ρ)))
      (`(quote ,atom) (α atom))
      (_ (α ae))))
  (include "primitives.rkt")
  (define (step)
    (define Ξ (hash))
    (define Ξi 0)
    (define (stack-alloc! τ κ)
      (let ((stacks (hash-ref Ξ τ #f)))
        (if stacks
            (unless (set-member? stacks κ)
              (set! Ξ (hash-set Ξ τ (set-add stacks κ)))
              (set! Ξi (add1 Ξi)))
            (begin
              (set! Ξ (hash-set Ξ τ (set κ)))
              (set! Ξi (add1 Ξi))))))
    (define (apply-local-kont ι κ v σ)
      (match ι
        ((cons (letk x e ρ) ι)
         (let* ((a (alloc x #f))
                (ρ* (env-bind ρ x a))
                (σ* (store-alloc σ a v)))
           (ev e ρ* σ* ι κ Ξi)))
        ((cons (letreck a e ρ) ι)
         (let ((σ* (store-update σ a v)))
           (ev e ρ σ* ι κ Ξi)))
        (_ (ko ι κ v σ Ξi))))
    (define (touches d)
      (if (set? d)
          (for/fold ((as (set))) ((v d)) (set-union as (touches v)))
          (match d
            ((ev e ρ _ ι κ _) (set-union (env-addresses (↓ ρ (free e))) (apply set-union (set-map (stack-frames ι κ) touches))))
            ((ko ι κ v _ _) (set-union (apply set-union (set-map (stack-frames ι κ) touches)) (touches v)))
            ((clo _ ρ) (env-addresses ρ))
            ((letk _ _ ρ) (env-addresses ρ))
            ((letreck _ _ ρ) (env-addresses ρ))
            ((addr a) (set a))
            ((cons x y) (set-union (touches x) (touches y)))
            (_ (set)))))
    (define (reachable A σ)
      (let loop ((A A) (R (set)))
        (if (set-empty? A)
            R
            (let ((a (set-first A)))
              (if (set-member? R a)
                  (loop (set-rest A) R)
                  (let* ((v (γ (store-lookup σ a)))
                         (T (touches v)))
                    (loop (set-union (set-rest A) T) (set-add R a))))))))
    (define (stack-frames ι κ)
      (let loop ((todo (set (cons ι κ))) (result (list->set ι)) (seen (set)))
        (if (set-empty? todo)
            result
            (let ((ικ (set-first todo)))
              (match ικ
                ((cons ι κ)
                 (let ((result* (set-union result (list->set ι))))
                   (if (or (not κ) (set-member? seen κ))
                       (loop (set-rest todo) result* seen)
                       (loop (set-union (set-rest todo) (stack-lookup Ξ κ)) result* (set-add seen κ))))))))))
    (define (stack-pop ι κ G)
      (if (null? ι)
          (if (or (not κ) (set-member? G κ))
              (set)
              (let ((ικs (stack-lookup Ξ κ)))
                (apply set-union (set-map ικs (lambda (ικ) (stack-pop (car ικ) (cdr ικ) (set-add G κ)))))))
          (set (list ι κ))))
    
    (lambda (s)
      (match s
        ((ev (? ae? ae) ρ σ ι κ _)
         (set (ko ι κ (eval-atom ae ρ σ) σ Ξi)))
        ((ev `(if ,ae ,e1 ,e2) ρ σ ι κ _)
         (let ((v (eval-atom ae ρ σ)))
           (set-union (if (true? v)
                          (set (ev e1 ρ σ ι κ Ξi))
                          (set))
                      (if (false? v)
                          (set (ev e2 ρ σ ι κ Ξi))
                          (set)))))
        ((ev `(let ((,x ,e0)) ,e1) ρ σ ι κ _)
         (set (ev e0 ρ σ (cons (letk x e1 ρ) ι) κ Ξi)))
        ((ev `(letrec ((,x ,e0)) ,e1) ρ σ ι κ _)
         (let* ((a (alloc x #f))
                (ρ* (env-bind ρ x a))
                (σ* (store-alloc σ a ⊥)))
           (set (ev e0 ρ* σ* (cons (letreck a e1 ρ*) ι) κ Ξi))))
        ((ev `(set! ,x ,ae) ρ σ ι κ _)
         (let* ((v (eval-atom ae))
                (a (env-lookup ρ x))
                (σ* (store-update σ a v)))
           (set (ko ι κ v σ* Ξi))))
        ((ev `(quote ,e) ρ σ ι κ _)
         (match-let (((cons v σ) (alloc-literal e σ)))
           (set (ko ι κ v σ Ξi))))
        ((ev (and `(,rator . ,rands) e) ρ σ ι κ _)
         (let* ((R (reachable (touches s) σ))
                (Γσ (↓ σ R)))
           (let ((v (eval-atom rator ρ Γσ)))
             (let loop ((rands rands) (rvs '()))
               (if (null? rands)
                   (for/fold ((states (set))) ((w (γ v)))
                     (match w
                       ((clo `(lambda ,x ,e0) ρ**)
                        (let loop ((x x) (vs (reverse rvs)) (ρ* ρ**) (σ* Γσ))
                          (match x
                            ('()
                             (let* ((τ (ctx w rvs Γσ)))
                               (stack-alloc! τ (cons ι κ))
                               (set-union states (set (ev e0 ρ* σ* '() τ Ξi)))))
                            ((cons x xs)
                             (if (null? vs)
                                 (set)
                                 (let ((a (alloc x e)))
                                   (loop xs (cdr vs) (env-bind ρ* x a) (store-alloc σ* a (car vs)))))))))
                       ((prim _ proc)
                        (set-union states (list->set (set-map (proc e (reverse rvs) Γσ ι κ Ξi) (lambda (vσ) (ko ι κ (car vσ) (cdr vσ) Ξi))))))
                       ((prim2 _ proc)
                        (set-union states (set (ko ι κ (apply proc (reverse rvs)) Γσ Ξi))))
                       (_ (set))))
                   (let ((v (eval-atom (car rands) ρ Γσ)))
                     (loop (cdr rands) (cons v rvs))))))))
        ((ko (cons (haltk) _) #f v _ _)
         (set))
        ((ko ι κ v σ _)
         (let ((ικs (stack-pop ι κ (set))))
           (for/set ((ικ ικs))
             (apply-local-kont (car ικ) (cadr ικ) v σ)))))))
  (define (inject e)
    (let ((global* (append global
                           `((eq? . ,(α (prim 'eq? prim-eq?)))
                             (equal? . ,(α (prim 'equal? prim-equal?)))
                             (error . ,(α (prim 'error prim-error)))
                             (pair? . ,(α (prim 'pair? prim-pair)))
                             (cons . ,(α (prim 'cons prim-cons)))
                             (reverse . ,(α (prim 'reverse prim-reverse)))
                             (car . ,(α (prim 'car prim-car)))
                             (cdr . ,(α (prim 'cdr prim-cdr)))))))
      (set! conc-alloc-counter 0)
      (let loop ((global global*) (ρ (hash)) (σ (hash)))
        (match global
          ('()
           (ev e (↓ ρ (free e)) σ `(,(haltk)) #f (hash)))
          ((cons (cons x v) r)
           (let ((a (conc-alloc x 0)))
             (loop r (hash-set ρ x a) (hash-set σ a v))))))))
  (define (answer? s)
    (match s
      ((ko (cons (haltk) _) _ v _ _) #t)
      (_ #f)))
  
  (machine ⊥ ⊔ inject step answer?))

(define (run s mach)
  (let ((step ((machine-step mach))))
    (let loop ((visited (set))
               (todo (set s)))
      (if (set-empty? todo)
          (system mach visited)
          (let ((s (set-first todo)))
            (if (set-member? visited s)
                (loop visited (set-rest todo))
                (loop (set-add visited s) (set-union (step s) (set-rest todo)))))))))

(define (explore e mach)
  (let ((inject (machine-inject mach)))
    (run (inject e) mach)))

(define (answer-set sys)
  (let ((answer? (machine-answer? (system-mach sys))))
    (for/fold ((v (set))) ((s (system-states sys)))
      (if (answer? s)
          (set-add v s)
          v))))

(define (answer-value sys)
  (let* ((mach (system-mach sys))
         (⊥ (machine-⊥ mach))
         (⊔ (machine-⊔ mach)))
    (for/fold ((v ⊥)) ((s (answer-set sys)))
      (⊔ (ko-v s) v))))

(define (do-eval e mach)
  (answer-value (explore e mach)))
;;

;; allocators
(define conc-alloc-counter 0)
(define conc-alloc
  (lambda (_ __)
    (set! conc-alloc-counter (add1 conc-alloc-counter))
    conc-alloc-counter))

(define (mono-alloc x _)
  x)

(define (poly-alloc x ctx)
  (cons x ctx))
;  (cons x (if ctx
;              (clo-λ (ctx-clo ctx))
;              ctx)))
;;

(include "lattice.rkt")
(include "test.rkt")


;; Some metrics
(define (state-size state)
  ;; Number of characters it takes to represent a state
  (round (/ (string-length (~a state)) 1000)))

(define (answer-size sys)
  ;; Total size of the answer set
  (foldl + 0 (map state-size (set->list (answer-set sys)))))

(define (avg-size sys)
  ;; Average size of a state
  (let ((states (answer-set sys)))
    (round (/ (foldl + 0 (map state-size (set->list states)))
              (set-count states)))))

(define (test . ens)
    (when (null? ens)
      (set! ens '(hellomemo blur fac fib eta gcipd kcfa2 kcfa3 loop2 mj09 rotate)))
  (define mach type-machine)
  (for ((en ens))
    (let* ((e (eval en))
           (memo-count 0)
           (memo-counter
            (lambda (msg)
              (set! memo-count (add1 memo-count)))))
      (set! MEMO memo-counter)
      (let* ((start (current-milliseconds))
             (sys (explore e mach))
             (duration (- (current-milliseconds) start)))
        (printf "~a result ~a states ~a time ~a size ~a avgsize ~a\n" en (answer-value sys) (set-count (system-states sys)) duration (answer-size sys) (avg-size sys))))))
