#lang racket

; garbage-collecting CESIK*Ξ machine for ANF Scheme (lambda if set! let letrec)
; gc on application evaluation
; guarded pop from Ξ with immediate (local) kont application (the halt state is still handled as an administractive step)
; local Ξ

(random-seed 111) ; deterministic random
(define MEMO (lambda (msg) #f))
(define DEBUG '())

;; general helpers
(define ns (make-base-namespace))
(define (↓ m s)
  (let loop ((s s) (r (hash)))
    (if (set-empty? s)
        r
        (let ((key (set-first s)))
          (loop (set-rest s) (hash-set r key (hash-ref m key)))))))
(define (value->file value file)
  (let ((out (open-output-file file #:exists 'replace)))
    (write value out)
    (close-output-port out)))
;;

;; domain helpers
(define (env-lookup ρ x)
  (hash-ref ρ x))
(define (env-addresses ρ)
  (list->set (hash-values ρ)))
(define (store-lookup σ a)
  (hash-ref σ a))
(define (stack-lookup Ξ τ)
  (hash-ref Ξ τ))
(define (ae? e)
  (match e
    ((? symbol? e) #t)
    (`(lambda ,_ ,_) #t)
    ((? boolean? e) #t)
    ((? number? e) #t)
    ((? string? e) #t)
    (`(quote ,e) (not (pair? e)))
    (_ #f)))
(define (free e)
  (define (f e env)
    (match e
      ((? symbol? e) (if (set-member? env e)
                         (set)
                         (set e)))
      (`(lambda ,x ,e) (f e (set-union env (list->set x))))
      (`(let ((,x ,e0)) ,e1) (set-union (f e0 env) (f e1 (set-add env x))))
      (`(letrec ((,x ,e0)) ,e1) (set-union (f e0 (set-add env x)) (f e1 (set-add env x))))
      (`(if ,ae ,e1 ,e2) (set-union (f ae env) (f e1 env) (f e2 env)))
      (`(set! ,x ,ae) (set-union (f x env) (f ae env) ))
      (`(quote ,_) (set))
      (`(,rator . ,rands) (set-union (f rator env) (for/fold ((xs (set))) ((rand rands)) (set-union xs (f rand env)))))
      (_ (set))))
  (f e (set)))
;;

;; machine
(struct machine (⊥ ⊔ inject step answer?) #:transparent)
(struct ev (e ρ σ ι κ Ξ) #:transparent)
(struct ko (ι κ v σ Ξ) #:transparent)
(struct ctx (clo vs σ) #:transparent)
(struct letk (x e ρ) #:transparent)
(struct letreck (a e ρ) #:transparent)
(struct haltk () #:transparent)
(struct clo (λ ρ) #:transparent)
(struct prim (λ) #:transparent)
(struct addr (a) #:transparent)
(struct system (mach states) #:transparent)

(define (make-machine global α γ ⊥ ⊔ alloc true? false? α-eq?)
  (define (env-bind ρ x a)
    (hash-set ρ x a))
  (define (store-alloc σ a v)
    (hash-set σ a (⊔ (hash-ref σ a ⊥) v)))
  (define (store-update σ a v)
    (hash-set σ a (⊔ (hash-ref σ a) v)))
  (define (eval-atom ae ρ σ)
    (match ae
      ((? symbol? ae) (store-lookup σ (env-lookup ρ ae)))
      (`(lambda ,x ,e0) (α (clo ae ρ)))
      (`(quote ,atom) (α atom))
      (_ (α ae))))
  (define (alloc-literal e σ)
    (if (pair? e)
        (match-let (((cons car-v car-σ) (alloc-literal (car e) σ)))
          (match-let (((cons cdr-v cdr-σ) (alloc-literal (cdr e) car-σ)))
            (let ((a (conc-alloc '%$lit e)))
              (cons (α (addr a)) (store-alloc cdr-σ a (α (cons car-v cdr-v)))))))
        (cons (α e) σ)))
  (define (prim-cons e rands σ ι κ Ξ)
    (displayln (list e rands))
    (if (= (length rands) 2)
        (let* ((a (alloc '!%cons e))
               (v (α (cons (car rands) (cadr rands))))
               (σ* (store-alloc σ a v)))
          (set (ko ι κ (α (addr a)) σ* Ξ)))
        (set)))
  (define (prim-car e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (for/fold ((states (set))) ((w (γ (car rands))))
          (match w
            ((addr a)
             (set-union states 
                        (for/fold ((states2 (set))) ((ww (γ (store-lookup σ a))))
                          (match ww
                            ((cons v _) (set-add states2 (ko ι κ v σ Ξ)))
                            (_ states2)))))
            (_ states)))
        (set)))
  (define (prim-cdr e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (for/fold ((states (set))) ((w (γ (car rands))))
          (match w
            ((addr a)
             (set-union states 
                        (for/fold ((states2 (set))) ((ww (γ (store-lookup σ a))))
                          (match ww
                            ((cons _ v) (set-add states2 (ko ι κ v σ Ξ)))
                            (_ states2)))))
            (_ states)))
        (set)))
  (define (prim-pair e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (let ((v (for/fold ((v ⊥)) ((w (γ (car rands))))
                   (match w
                     ((addr a)
                      (⊔ v 
                         (for/fold ((v2 ⊥)) ((ww (γ (store-lookup σ a))))
                           (match ww
                             ((cons _ _) (⊔ v2 (α #t)))
                             (_ (⊔ v2 (α #f)))))))
                     (_ (⊔ v (α #f)))))))
          (set (ko ι κ v σ Ξ)))
        (set)))  
  (define (prim-reverse e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (let loop ((lst (car rands)) (rev (α '())) (σ σ) (seen (set)))
          (for/fold ((states (set))) ((w (γ lst)))
            (match w
              ('() (set (ko ι κ rev σ Ξ)))
              ((addr a)
               (if (set-member? seen a)
                   states
                   (set-union states 
                              (for/fold ((states2 (set))) ((ww (γ (store-lookup σ a))))
                                (match ww
                                  ((cons v-car v-cdr)
                                   (let* ((aa (alloc '$%rev e))
                                          (σ* (store-alloc σ aa (α (cons v-car rev)))))
                                     (set-union states2 (loop v-cdr (α (addr aa)) σ* (set-add seen a)))))
                                  (_ states2))))))
              (_ states))))
        (set)))
  (define (equal?-helper v1 v2 σ)
    (match* (v1 v2)
      (((addr a1) (addr a2))
       (let ((v1 (store-lookup σ a1))
             (v2 (store-lookup σ a2)))
         (equal?-helper v1 v2 σ)))
      (((cons v1 v2) (cons v3 v4))
       (let ((car-equal (equal?-helper v1 v3 σ)))
         (if (true? car-equal)
             (⊔ car-equal (equal?-helper v2 v4 σ))
             (α #f))))
      ((_ _) (α-eq? v1 v2))))
  (define (prim-equal? e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let* ((w1 (γ (car rands)))
               (w2 (γ (cadr rands)))
               (v (for*/fold ((v ⊥)) ((v1 w1) (v2 w2)) (⊔ v (equal?-helper v1 v2 σ)))))
          (set (ko ι κ v σ Ξ)))
        (set)))
  (define (eq?-helper v1 v2 σ)
    (match* (v1 v2)
      (((addr a1) (addr a2))
       (α (equal? a1 a2)))
      ((_ _) (α-eq? v1 v2))))
  (define (prim-eq? e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let* ((w1 (γ (car rands)))
               (w2 (γ (cadr rands)))
               (v (for*/fold ((v ⊥)) ((v1 w1) (v2 w2)) (⊔ v (eq?-helper v1 v2 σ)))))
          (set (ko ι κ v σ Ξ)))
        (set)))
  (define (prim-error e rands σ ι κ Ξ)
    (set))
  (define (step Ξ)
    (define (stack-alloc τ κ)
      (hash-set Ξ τ (set-union (hash-ref Ξ τ (set)) (set κ))))
    (define (apply-local-kont ι κ v σ)
      (match ι
        ((cons (letk x e ρ) ι)
         (let* ((a (alloc x #f))
                (ρ* (env-bind ρ x a))
                (σ* (store-alloc σ a v)))
           (ev e ρ* σ* ι κ Ξ)))
        ((cons (letreck a e ρ) ι)
         (let ((σ* (store-update σ a v)))
           (ev e ρ σ* ι κ Ξ)))
        (_ (ko ι κ v σ Ξ))))
    (define (touches d)
      (if (set? d)
          (for/fold ((as (set))) ((v d)) (set-union as (touches v)))
          (match d
            ((ev _ ρ _ ι κ _) (set-union (env-addresses ρ) (apply set-union (set-map (stack-frames ι κ) touches))))
            ((ko ι κ v _ _) (set-union (apply set-union (set-map (stack-frames ι κ) touches)) (touches v)))
            ((clo _ ρ) (env-addresses ρ))
            ((letk _ _ ρ) (env-addresses ρ))
            ((letreck _ _ ρ) (env-addresses ρ))
            ((addr a) (set a))
            ((cons x y) (set-union (touches x) (touches y)))
            (_ (set)))))
    (define (reachable A σ)
      (let loop ((A A) (R (set)))
        (if (set-empty? A)
            R
            (let ((a (set-first A)))
              (if (set-member? R a)
                  (loop (set-rest A) R)
                  (let* ((v (γ (store-lookup σ a)))
                         (T (touches v)))
                    (loop (set-union (set-rest A) T) (set-add R a))))))))
    (define (stack-frames ι κ)
      (let loop ((todo (set (cons ι κ))) (result (list->set ι)) (seen (set)))
        (if (set-empty? todo)
            result
            (let ((ικ (set-first todo)))
              (match ικ
                ((cons ι κ)
                 (let ((result* (set-union result (list->set ι))))
                   (if (or (not κ) (set-member? seen κ))
                       (loop (set-rest todo) result* seen)
                       (loop (set-union (set-rest todo) (stack-lookup Ξ κ)) result* (set-add seen κ))))))))))
    (define (stack-pop ι κ G)
      (if (null? ι)
          (if (or (not κ) (set-member? G κ))
              (set)
              (let ((ικs (stack-lookup Ξ κ)))
                (apply set-union (set-map ικs (lambda (ικ) (stack-pop (car ικ) (cdr ικ) (set-add G κ)))))))
          (set (list ι κ))))
    
    (lambda (s)
      (match s
        ((ev (? ae? ae) ρ σ ι κ _)
         (set (ko ι κ (eval-atom ae ρ σ) σ Ξ)))
        ((ev `(if ,ae ,e1 ,e2) ρ σ ι κ _)
         (let ((v (eval-atom ae ρ σ)))
           (set-union (if (true? v)
                          (set (ev e1 ρ σ ι κ Ξ))
                          (set))
                      (if (false? v)
                          (set (ev e2 ρ σ ι κ Ξ))
                          (set)))))
        ((ev `(let ((,x ,e0)) ,e1) ρ σ ι κ _)
         (set (ev e0 ρ σ (cons (letk x e1 ρ) ι) κ Ξ)))
        ((ev `(letrec ((,x ,e0)) ,e1) ρ σ ι κ _)
         (let* ((a (alloc x #f))
                (ρ* (env-bind ρ x a))
                (σ* (store-alloc σ a ⊥)))
           (set (ev e0 ρ* σ* (cons (letreck a e1 ρ*) ι) κ Ξ))))
        ((ev `(set! ,x ,ae) ρ σ ι κ _)
         (let* ((v (eval-atom ae))
                (a (env-lookup ρ x))
                (σ* (store-update σ a v)))
           (set (ko ι κ v σ* Ξ))))
        ((ev `(quote ,e) ρ σ ι κ _)
         (match-let (((cons v σ) (alloc-literal e σ)))
           (set (ko ι κ v σ Ξ))))
        ((ev (and `(,rator . ,rands) e) ρ σ ι κ _)
         (let* ((R (reachable (touches s) σ))
                (Γσ (↓ σ R)))
           (let ((v (eval-atom rator ρ Γσ)))
             (let loop ((rands rands) (rvs '()))
               (if (null? rands)
                   (for/fold ((states (set))) ((w (γ v)))
                     (match w
                       ((clo `(lambda ,x ,e0) ρ**)
                        (let loop ((x x) (vs (reverse rvs)) (ρ* ρ**) (σ* Γσ))
                          (match x
                            ('()
                             (let* ((τ (ctx w rvs Γσ)))
                               (set! Ξ (stack-alloc τ (cons ι κ)))
                               (set-union states (set (ev e0 ρ* σ* '() τ Ξ)))))
                            ((cons x xs)
                             (if (null? vs)
                                 (set)
                                 (let ((a (alloc x e)))
                                   (loop xs (cdr vs) (env-bind ρ* x a) (store-alloc σ* a (car vs)))))))))
                       ((prim λ)
                        (set-union states (λ e (reverse rvs) Γσ ι κ Ξ)))
                       ((? procedure? w)
                        (set-union states (set (ko ι κ (apply w (reverse rvs)) Γσ Ξ))))
                       (_ (set))))
                   (let ((v (eval-atom (car rands) ρ Γσ)))
                     (loop (cdr rands) (cons v rvs))))))))
        ((ko (cons (haltk) _) #f v _ _)
         (set))
        ((ko ι κ v σ _)
         (let ((ικs (stack-pop ι κ (set))))
           (for/set ((ικ ικs))
             (apply-local-kont (car ικ) (cadr ικ) v σ)))))))
  (define (inject e)
    (let ((global* (append global
                           `((eq? . ,(α (prim prim-eq?))))
                           `((equal? . ,(α (prim prim-equal?))))
                           `((error . ,(α (prim prim-error))))
                           `((pair? . ,(α (prim prim-pair))))
                           `((cons . ,(α (prim prim-cons))))
                           `((reverse . ,(α (prim prim-reverse))))
                           `((car . ,(α (prim prim-car))))
                           `((cdr . ,(α (prim prim-cdr)))))))
      (let loop ((global global*) (ρ (hash)) (σ (hash)))
        (match global
          ('()
           (ev e (↓ ρ (free e)) σ `(,(haltk)) #f (hash)))
          ((cons (cons x v) r)
           (let ((a (conc-alloc x 0)))
             (loop r (hash-set ρ x a) (hash-set σ a v))))))))
  (define (answer? s)
    (match s
      ((ko (cons (haltk) _) _ v _ _) #t)
      (_ #f)))
  
  (machine ⊥ ⊔ inject step answer?))

(define (run s mach)
  (let ((step ((machine-step mach) (hash))))
    (let loop ((visited (set))
               (todo (set s)))
      (if (set-empty? todo)
          (system mach visited)
          (let ((s (set-first todo)))
            (if (set-member? visited s)
                (loop visited (set-rest todo))
                (loop (set-add visited s) (set-union (step s) (set-rest todo)))))))))

(define (explore e mach)
  (let ((inject (machine-inject mach)))
    (run (inject e) mach)))

(define (answer-set sys)
  (let ((answer? (machine-answer? (system-mach sys))))
    (for/fold ((v (set))) ((s (system-states sys)))
      (if (answer? s)
          (set-add v s)
          v))))

(define (answer-value sys)
  (let* ((mach (system-mach sys))
         (⊥ (machine-⊥ mach))
         (⊔ (machine-⊔ mach)))
    (for/fold ((v ⊥)) ((s (answer-set sys)))
      (⊔ (ko-v s) v))))

(define (do-eval e mach)
  (answer-value (explore e mach)))
;;

;; allocators
(define conc-alloc
  (let ((counter 0))
    (lambda (_ __)
      (set! counter (+ counter 1))
      counter)))

(define (mono-alloc x _)
  x)

(define (poly-alloc x ctx)
  (cons x ctx))
;  (cons x (if ctx
;              (clo-λ (ctx-clo ctx))
;              ctx)))
;;

(include "lattice.rkt")
(include "test.rkt")

;; Some metrics
(define (state-size state)
  ;; Number of characters it takes to represent a state
  (round (/ (string-length (~a state)) 1000)))

(define (answer-size sys)
  ;; Total size of the answer set
  (foldl + 0 (map state-size (set->list (answer-set sys)))))

(define (avg-size sys)
  ;; Average size of a state
  (let ((states (answer-set sys)))
    (round (/ (foldl + 0 (map state-size (set->list states)))
              (set-count states)))))

(define (test)
  (define ens '(hellomemo blur fac fib eta gcipd kcfa2 kcfa3 loop2 mj09 rotate))
  (define mach type-machine)
  (for ((en ens))
    (let* ((e (eval en))
           (memo-count 0)
           (memo-counter
            (lambda (msg)
              (set! memo-count (add1 memo-count)))))
      (set! MEMO memo-counter)
      (let* ((start (current-milliseconds))
             (sys (explore e mach))
             (duration (- (current-milliseconds) start)))
        (printf "~a result ~a states ~a time ~a size ~a avgsize ~a\n" en (answer-value sys) (set-count (system-states sys)) duration (answer-size sys) (avg-size sys))))))
