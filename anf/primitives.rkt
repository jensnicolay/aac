  (define (alloc-literal e σ)
    (if (pair? e)
        (match-let (((cons car-v car-σ) (alloc-literal (car e) σ)))
          (match-let (((cons cdr-v cdr-σ) (alloc-literal (cdr e) car-σ)))
            (let ((a (conc-alloc '%$lit e)))
              (cons (α (addr a)) (store-alloc cdr-σ a (α (cons car-v cdr-v)))))))
        (cons (α e) σ)))
  (define (prim-cons e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let* ((a (alloc '!%cons e))
               (v (α (cons (car rands) (cadr rands))))
               (σ* (store-alloc σ a v)))
          (set (cons (α (addr a)) σ*)))
        (set)))
  (define (prim-car e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (for/fold ((states (set))) ((w (γ (car rands))))
          (match w
            ((addr a)
             (set-union states 
                        (for/fold ((states2 (set))) ((ww (γ (store-lookup σ a))))
                          (match ww
                            ((cons v _) (set-add states2 (cons v σ)))
                            (_ states2)))))
            (_ states)))
        (set)))
  (define (prim-cdr e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (for/fold ((states (set))) ((w (γ (car rands))))
          (match w
            ((addr a)
             (set-union states 
                        (for/fold ((states2 (set))) ((ww (γ (store-lookup σ a))))
                          (match ww
                            ((cons _ v) (set-add states2 (cons v σ)))
                            (_ states2)))))
            (_ states)))
        (set)))
  (define (prim-pair e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (let ((v (for/fold ((v ⊥)) ((w (γ (car rands))))
                   (match w
                     ((addr a)
                      (⊔ v 
                         (for/fold ((v2 ⊥)) ((ww (γ (store-lookup σ a))))
                           (match ww
                             ((cons _ _) (⊔ v2 (α #t)))
                             (_ (⊔ v2 (α #f)))))))
                     (_ (⊔ v (α #f)))))))
          (set (cons v σ)))
        (set)))  
  (define (prim-reverse e rands σ ι κ Ξ)
    (if (= (length rands) 1)
        (let loop ((lst (car rands)) (rev (α '())) (σ σ) (seen (set)))
          (for/fold ((states (set))) ((w (γ lst)))
            (match w
              ('() (set (cons rev σ)))
              ((addr a)
               (if (set-member? seen a)
                   states
                   (set-union states 
                              (for/fold ((states2 (set))) ((ww (γ (store-lookup σ a))))
                                (match ww
                                  ((cons v-car v-cdr)
                                   (let* ((aa (alloc '$%rev e))
                                          (σ* (store-alloc σ aa (α (cons v-car rev)))))
                                     (set-union states2 (loop v-cdr (α (addr aa)) σ* (set-add seen a)))))
                                  (_ states2))))))
              (_ states))))
        (set)))
  (define (equal?-helper v1 v2 σ)
    (match* (v1 v2)
      (((addr a1) (addr a2))
       (let ((v1 (store-lookup σ a1))
             (v2 (store-lookup σ a2)))
         (equal?-helper v1 v2 σ)))
      (((cons v1 v2) (cons v3 v4))
       (let ((car-equal (equal?-helper v1 v3 σ)))
         (if (true? car-equal)
             (⊔ car-equal (equal?-helper v2 v4 σ))
             (α #f))))
      ((_ _) (α-eq? v1 v2))))
  (define (prim-equal? e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let* ((w1 (γ (car rands)))
               (w2 (γ (cadr rands)))
               (v (for*/fold ((v ⊥)) ((v1 w1) (v2 w2)) (⊔ v (equal?-helper v1 v2 σ)))))
          (set (cons v σ)))
        (set)))
  (define (eq?-helper v1 v2 σ)
    (match* (v1 v2)
      (((addr a1) (addr a2))
       (α (equal? a1 a2)))
      ((_ _) (α-eq? v1 v2))))
  (define (prim-eq? e rands σ ι κ Ξ)
    (if (= (length rands) 2)
        (let* ((w1 (γ (car rands)))
               (w2 (γ (cadr rands)))
               (v (for*/fold ((v ⊥)) ((v1 w1) (v2 w2)) (⊔ v (eq?-helper v1 v2 σ)))))
          (set (cons v σ)))
        (set)))
  (define (prim-error e rands σ ι κ Ξ)
    (set))
