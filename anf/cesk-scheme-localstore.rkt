#lang racket
(require racket/hash)
(require "general.rkt")
(require "ast.rkt")
(require "lattice.rkt")
(require "test.rkt")

; AAC, local store, global stack store
; set!, cons, vector 

(random-seed 111) ; deterministic random
(define CESK-TIMELIMIT (make-parameter 2)) ; timeout in minutes
(define (index v x)
  (let ((i (vector-member x v)))
    (if i
        i
        (let ((i (add1 (vector-ref v 0))))
          (vector-set! v 0 i)
          (vector-set! v i x)
          i))))
(define frameis (make-vector 1000))
(define (frame->framei frame) (index frameis frame))
(define envis (make-vector 1000))
(define (env->envi env) (index envis env))
(define ctxis (make-vector 1000))
(define (ctx->ctxi ctx) (index ctxis ctx))
(define stateis (make-vector 2000))
(define (state->statei q) (index stateis q))
(define storeis (make-vector 1000))
(define (store->storei σ) (index storeis σ))

;; domain helpers
(define (env-lookup ρ x)
  (hash-ref ρ x))
(define (env-addresses ρ)
  (list->set (hash-values ρ)))
(define (store-lookup σ a)
  (hash-ref σ a))
(define (store-⊒ σ1 σ2 ⊒)
  (if (eq? σ1 σ2)
      #t
      (if (< (hash-count σ1) (hash-count σ2))
          #f
          (for/and (((k v) σ1))
            (and (hash-has-key? σ2)
                 (⊒ v (hash-ref σ2 k)))))))
(define (stack-lookup Ξ τ)
  (hash-ref Ξ τ))

;; should become API on machine (system)
(define (state-κ s)
  (match s
    ((ev _ _ _ _ κ) κ)
    ((ko _ _ _ κ) κ)))

;; machine
(struct ev (e ρ σ ι κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "EV ~a\nρ ~a\nι ~a\nκ ~a" (ev-e v) (ev-ρ v) (ev-ι v) (ev-κ v))))
(struct ko (v σ ι κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "KO v ~a\nι ~a\nκ ~a" (ko-v v) (ko-ι v) (ko-κ v))))
(struct letk (x e ρ) #:transparent)
(struct letreck (x e ρ) #:transparent)
(struct clo (lam ρ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<clo ~a>" («lam»-l (clo-lam v)))))
(struct prim (name proc) #:methods gen:equal+hash ((define equal-proc (lambda (s1 s2 requal?)
                                                                        (equal? (prim-name s1) (prim-name s2))))
                                                   (define hash-proc (lambda (s rhash) (equal-hash-code (prim-name s))))
                                                   (define hash2-proc (lambda (s rhash) (equal-secondary-hash-code (prim-name s))))))
(struct addr (a) #:transparent)

(struct ctx (e clo rands A) #:transparent)
(struct transition (s) #:transparent)

(struct system (states duration initial graph Ξ Ξi lattice answer? exit msg) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "<sys #~a ~a ~a>" (vector-length (system-states v)) (system-exit v) (~a (system-msg v) #:max-width 70))))

(define (touches d)
  (if (set? d)
      (for/fold ((as (set))) ((v d)) (set-union as (touches v)))
      (match d
        ((clo _ ρ) (env-addresses ρ))
        ((letk _ _ ρ) (env-addresses ρ))
        ((letreck _ _ ρ) (env-addresses ρ))
        ((addr a) (set a))
        ((cons x y) (set-union (touches x) (touches y)))
        (_ (set)))))
(define (reachable A σ γ)
  (let loop ((A A) (R (set)))
    (if (set-empty? A)
        R
        (let ((a (set-first A)))
          (if (set-member? R a)
              (loop (set-rest A) R)
              (let* ((v (γ (store-lookup σ a)))
                     (T (touches v)))
                (loop (set-union (set-rest A) T) (set-add R a))))))))

;(define (gc s Ξ γ ctx-A)
;  (match s
;    ((ev e ρ σ ι κ)
;     (let* ((ρ* (↓ ρ (free e)))
 ;           (R (reachable (set-union (env-addresses ρ*) (stack-addresses ι κ ctx-A)) σ γ))
;            (σ* (↓ σ R)))
;       (ev e ρ* σ* ι κ)))
;    ((ko ι κ v σ)
;     (let* ((R (reachable (set-union (touches v) (stack-addresses ι κ ctx-A)) σ γ))
;            (σ* (↓ σ R)))
;       (ko ι κ v σ*)))))
(define (stack-pop ι κ Ξ G)
  (if (null? ι)
      (if κ
          (if (set-member? G κ)
              (set)
              (let ((ικs (stack-lookup Ξ κ)))
                (for/fold ((R (set))) ((ικ ικs))
                  (set-union R (stack-pop (car ικ) (cdr ικ) Ξ (set-add G κ))))))
          (set (list '() #f G)))
      (set (list ι κ G))))
(define (stack-addresses ι κ σ γ)
  (let ((A (for/fold ((A (set))) ((φ ι))
             (set-union A (touches φ)))))
    (set-union (if κ (ctx-A κ) (set)) (reachable A σ γ))))

(define (make-machine lattice alloc kalloc monotonic-store)

  (define α (lattice-α lattice))
  (define γ (lattice-γ lattice))
  (define ⊥ (lattice-⊥ lattice))
  (define ⊑ (lattice-⊑ lattice))
  (define ⊔ (lattice-⊔ lattice))
  (define true? (lattice-true? lattice))
  (define false? (lattice-false? lattice))
  (define α-eq? (lattice-eq? lattice))

  
  (define (explore e)
    (define Ξ (hash))
    (define Ξi 0)
    
    (include "primitives.rkt")
    
    (define (inject e)
      (let ((global* (append (lattice-global lattice) ; all fresh (freshness analysis supposes this: UNWANTED DEP!)
                             `(("eq?" . ,(α (prim "eq?" prim-eq?)))
                               ("~a" . ,(α (prim "~a" prim-to-string)))
                               ("list->string" . ,(α (prim "list->string" prim-to-string)))
                               ("error" . ,(α (prim "error" prim-error)))
                               ("pair?" . ,(α (prim "pair?" prim-pair)))
                               ("vector-length" . ,(α (prim "vector-length" prim-vector-length)))
                               ("vector-copy" . ,(α (prim "vector-copy" prim-vector-copy)))
                               )))
            (compiled-e (compile e)))
        (set! conc-alloc-counter 0)
        (let loop ((global global*) (ρ (hash)) (σ (hash)))
          (match global
            ('()
             (let* ((ρ* (↓ ρ (free compiled-e)))
                    (R (reachable (env-addresses ρ*) σ γ))
                    (σ* (↓ σ R)))
                    ;(κ0 (
               (ev compiled-e ρ* σ* '() #f)))
            ((cons (cons x v) r)
             (let* ((a (conc-alloc))
                    (ρ* (env-bind ρ x a))
                    (σ* (store-alloc σ a v)))
               (loop r ρ* σ*)))))))
    
    (define (env-bind ρ x a)
      (hash-set ρ x a))

    (define (store-lookup σ a)
      (hash-ref σ a))
    
    (define (store-alloc σ a v)
      (if (hash-has-key? σ a) 
          (let* ((current (hash-ref σ a))
                 (updated (⊔ current v)))
            (if (equal? current updated)
                σ
                (hash-set σ a updated)))
          (hash-set σ a v)))
          
    (define (store-update σ a v)
      (let* ((current (hash-ref σ a))
             (updated (⊔ current v)))
        (if (equal? current updated)
            σ
            (hash-set σ a updated))))
      
    (define (stack-alloc! κ stack)
      ;(printf "allocing ctx ~a stack ~a " (ctx->ctxi τ) (stack-to-string stack))
      (let ((stacks (hash-ref Ξ κ #f)))
        (if stacks
            (unless (set-member? stacks stack)
              ;(printf "ADDING to ~a\n" (set-map stacks stack-to-string))
              (set! Ξ (hash-set Ξ κ (set-add stacks stack)))
              (set! Ξi (add1 Ξi)))
            (begin 
              (set! Ξ (hash-set Ξ κ (set stack)))
              (set! Ξi (add1 Ξi))))))
    
    (define (alloc-literal e σ)
      (define (alloc-helper e)
        (if (pair? e)
            (let ((car-v (alloc-helper (car e))))
              (let ((cdr-v (alloc-helper (cdr e))))
                (let ((a (alloc e e)))
                  (set! σ (store-alloc σ a (α (cons car-v cdr-v))))
                  (α (addr a)))))
            (α e)))
      (values (alloc-helper e) σ))
    
    (define (eval-atom ae ρ σ)
      (match ae
        ((«lit» _ v)
         (α v))
        ((«id» _ x)
         (let ((a (env-lookup ρ x)))
           (store-lookup σ a)))
        ((«lam» _ x e)
         (let ((cl (clo ae ρ)))
           (α cl)))
        ((«quo» _ atom)
         (α atom))
        (_ (error "cannot handle ae" ae))))
    
    (define (apply-local-kont σ ι κ v)
      (match ι
        ((cons (letk x e ρ) ι)
          (let* ((a (alloc x κ))
                 (ρ* (env-bind ρ («id»-x x) a))
                 (σ* (store-alloc σ a v)))
          (set (transition (ev e ρ* σ* ι κ)))))
        ((cons (letreck x e ρ) ι)
          (let* ((a (env-lookup ρ («id»-x x)))
                 (σ* (store-update σ a v)))
            (set (transition (ev e ρ σ* ι κ)))))
        (_ (set (transition (ko v σ ι κ))))))

  (define (apply-proc e d-clo rands σ-caller ι κ)
    (match-let (((clo («lam» _ x e0) ρ) d-clo))
      (define (bind-loop x vs ρ σ)
        (match x
          ('()
           (let* ((A (stack-addresses ι κ σ γ))
                  (κ* (kalloc e clo rands A)))
             (stack-alloc! κ* (cons ι κ))
             (set (transition (ev e0 ρ σ '() κ*)))))
          ((cons x xs)
           (if (null? vs)
               (set)
               (let* ((a (alloc x e))
                      (ρ* (env-bind ρ («id»-x x) a))
                      (σ* (store-alloc σ a (car vs))))
                 (bind-loop xs (cdr vs) ρ* σ*))))))
      (bind-loop x rands ρ σ-caller)))
        
    (define (print-state q)
      (match q
        ((ev e ρ σ ι κ)
         (printf "EV ~a\n" (~a e #:max-width 40))
         (printf "ρ ~a ~a\n" (env->envi ρ) ρ)
         (printf "σ ~a ~a\n" σ (store->storei σ))
         (printf "ι    ~a\n" (map frame->framei ι))
         (printf "κ ~a ~a\n" (ctx->ctxi κ) κ))
        ((ko v σ ι κ)
         (printf "KO ~a\n" (~a v #:max-width 40))
         (printf "σ ~a ~a\n" σ (store->storei σ))
         (printf "ι    ~a\n" (map frame->framei ι))
         (printf "κ ~a ~a\n" (ctx->ctxi κ) κ))))
    
    (define (step s)
      ;(printf "\nexploring ~a\n" (state->statei s))
      ;(print-state s)
      ;(read)
      (match s
        ((ev (? ae? ae) ρ σ ι κ)
         (let ((v (eval-atom ae ρ σ)))
           (set (transition (ko v σ ι κ)))))
        ((ev («if» _ ae e1 e2) ρ σ ι κ)
         (let ((v (eval-atom ae ρ σ)))
           (set-union (if (true? v)
                          (set (transition (ev e1 ρ σ ι κ)))
                          (set))
                      (if (false? v)
                          (set (transition (ev e2 ρ σ ι κ)))
                          (set)))))
        ((ev («let» _ x e0 e1) ρ σ ι κ)
         (set (transition (ev e0 ρ σ (cons (letk x e1 ρ) ι) κ))))
        ((ev («letrec» _ x e0 e1) ρ σ ι κ)
         (let* ((a (alloc x κ))
                (ρ* (env-bind ρ («id»-x x) a))
                (σ* (store-alloc σ a ⊥)))
           (set (transition (ev e0 ρ* σ* (cons (letreck x e1 ρ*) ι) κ)))))
        ((ev («set!» _ x ae) ρ σ ι κ)
         (let* ((v (eval-atom ae ρ σ))
                (a (env-lookup ρ («id»-x x)))
                (σ* (store-update σ a v)))
           (set (transition (ko (α 'undefined) σ* ι κ)))))
        ((ev («quo» _ e) ρ σ ι κ)
         (let-values (((v σ*) (alloc-literal e σ)))
           (set (transition (ko v σ* ι κ)))))
        ((ev («car» _ x) ρ σ ι κ)
         (let* ((v1 (eval-atom x ρ σ))
                (v (for/fold ((v ⊥)) ((w (γ v1)))
                     (match w
                       ((addr a)
                        (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                          (match ww
                            ((cons v-car _) (⊔ v v-car))
                            (_ v))))
                       (_ v))))) 
             (set (transition (ko v σ ι κ)))))
        ((ev («cdr» _ x) ρ σ ι κ)
         (let* ((v1 (eval-atom x ρ σ))
                (v (for/fold ((v ⊥)) ((w (γ v1)))
                     (match w
                       ((addr a)
                        (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                          (match ww
                            ((cons _ v-cdr) (⊔ v v-cdr))
                            (_ v))))
                       (_ v))))) 
             (set (transition (ko v σ ι κ)))))
        ((ev («set-car!» _ x ae) ρ σ ι κ)
         (let* ((v1 (eval-atom x ρ σ))
                (v2 (eval-atom ae ρ σ))
                (σ (for/fold ((σ σ)) ((w (γ v1)))
                      (match w
                        ((addr a)
                         (for/fold ((σ σ)) ((ww (γ (store-lookup σ a))))
                           (match ww
                             ((cons _ v-cdr)
                              (store-update σ a (α (cons v2 v-cdr))))
                             (_ σ))))
                        (_ σ)))))
             (set (transition (ko (α 'undefined) σ ι κ)))))
        ((ev («set-cdr!» _ x ae) ρ σ ι κ)
         (let* ((v1 (eval-atom x ρ σ))
                (v2 (eval-atom ae ρ σ))
                (σ (for/fold ((σ σ)) ((w (γ v1)))
                      (match w
                        ((addr a)
                         (for/fold ((σ σ)) ((ww (γ (store-lookup σ a))))
                           (match ww
                             ((cons v-car _)
                              (store-update σ a (α (cons v-car v2))))
                             (_ σ))))
                        (_ σ)))))
             (set (transition (ko (α 'undefined) σ ι κ)))))
        ((ev (and («cons» _ ae1 ae2) e) ρ σ ι κ)
         (let* ((v1 (eval-atom ae1 ρ σ))
                (v2 (eval-atom ae2 ρ σ))
                (a (alloc e κ))
                (v (α (cons v1 v2)))
                (σ* (store-alloc σ a v)))
           (set (transition (ko (α (addr a)) σ* ι κ)))))
        ((ev («vector-ref» _ x ae) ρ σ ι κ)
         (let* ((v1 (eval-atom x ρ σ))
                (v2 (eval-atom ae ρ σ))
                (index v2)
                (v (for/fold ((v ⊥)) ((w (γ v1)))
                     (match w
                       ((addr a)
                        (for/fold ((v v)) ((ww (γ (store-lookup σ a))))
                          (if (hash? ww)
                              (for/fold ((v v)) (((key val) ww))
                                (if (or (⊑ index key) (⊑ key index) )
                                    (⊔ v val)
                                    v))
                              v)))
                       (_ σ)))))
           (set (transition (ko v σ ι κ)))))
        ((ev («vector-set!» _ x ae1 ae2) ρ σ ι κ)
         (let* ((v1 (eval-atom x ρ σ))
                (v2 (eval-atom ae1 ρ σ))
                (v3 (eval-atom ae2 ρ σ))
                (σ* (for/fold ((σ σ)) ((w (γ v1)))
                      (match w
                        ((addr a)
                          (for/fold ((σ σ)) ((ww (γ (store-lookup σ a))))
                               (if (hash? ww)
                                   (store-update σ a (α (hash-set ww v2 (⊔ (hash-ref ww v2 ⊥) v3))))
                                   σ)))
                        (_ σ)))))
           (set (transition (ko (α 'undefined) σ* ι κ)))))
        ((ev (and («make-vector» _ ae1 ae2) e) ρ σ ι κ)
         (let* ((v1 (eval-atom ae1 ρ σ))
                (v2 (eval-atom ae2 ρ σ))
                (a (alloc e κ))
                (num v1)
                (global (lattice-global lattice))
                (lt-proc (lambda (x y)
                           (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "<" global)))) )
                             (⊔ result ((prim2-proc prim2) x y)))))
                (add-proc (lambda (x y)
                            (for/fold ((result ⊥)) ((prim2 (γ (cdr (assoc "+" global))) ))
                            (⊔ result ((prim2-proc prim2) x y)))))
                (init v2)
                (h (hash)))
            (let loop ((h h) (i (α 0)) (σ σ))
              (if (and (true? (lt-proc i num)) (not (hash-has-key? h i)))
                  (loop (hash-set h i init) (add-proc i (α 1)) σ)
                  (let* ((v (α h))
                          (σ* (store-alloc σ a v)))
                    (set (transition (ko (α (addr a)) σ ι κ))))))))
        ((ev (and («app» _ rator rands) e) ρ σ ι κ)
         (let ((v (eval-atom rator ρ σ)))
           (let rands-loop ((rands rands) (rvs '()))
             (if (null? rands)
                 (for/fold ((succ (set))) ((w (γ v)))
                   (match w
                     ((clo _ _)
                      (set-union succ (apply-proc e w (reverse rvs) σ ι κ)))
                     ((prim name proc)
                      (set-union succ (proc e (reverse rvs) σ ι κ)))
                     ((prim2 _ proc)
                      (set-add succ (transition (ko (apply proc (reverse rvs)) σ ι κ))))
                     (_ succ)))
                 (let ((v (eval-atom (car rands) ρ σ)))
                   (rands-loop (cdr rands) (cons v rvs)))))))
        ((ko _ _ '() #f)
         (set))
        ((ko v σ ι κ)
         (if (eq? v ⊥)
             (set)
             (let* ((ικGs (stack-pop ι κ Ξ (set))))
               (let loop ((ικGs ικGs) (succ (set)))
                 (if (set-empty? ικGs)
                     succ
                     (let* ((ικG (set-first ικGs))
                            (ι (car ικG))
                            (κ (cadr ικG))
                            (G (caddr ικG))
                            (succ* (apply-local-kont σ ι κ v)))
                       (loop (set-rest ικGs)
                             (set-union succ succ*))))))))
        )) ; end step
    
    (define states (mutable-set))
    (define initial (inject e))
    (define (make-system graph duration exit msg)
      (system (list->vector (set->list states)) duration initial graph Ξ Ξi lattice answer? exit msg))


    ;(define state-limit (STATELIMIT))
    (define time-limit (+ (current-milliseconds) (* (CESK-TIMELIMIT) 60000)))

    (define (handle-transition W graph s)
      (for/fold ((W W) (graph graph)) ((t (step s)))
        (match t
          ((transition s*)
           ;(printf "~a -> ~a\n" (state->statei s) (state->statei (transition-s t)))
           (let ((W* (set-add W s*))
                 (graph*
                  (let ((hs (hash-ref graph s (set))))
                    (hash-set graph s (set-add hs s*)))))
             (values W* graph*))))))

    (define (explore-loop S W graph)
      (if (and (zero? (remainder (set-count states) 10000))
               (> (current-milliseconds) time-limit))
          (make-system graph (- (current-milliseconds) start) 'user "time out")
          (if (set-empty? W)
              (make-system graph (- (current-milliseconds) start) 'ok "")
              (let* ((s (set-first W)))
                (if (set-member? S s)
                    (explore-loop S (set-rest W) graph)
                    ;(printf "s ~a\n" (state->statei s))
                    (let ((old-Ξi Ξi))
                      (let-values (((W* graph*) (handle-transition (set-rest W) graph s)))
                        (let ((S* (if (> Ξi old-Ξi)
                                      (set)
                                      (set-add S s))))
                        (set-add! states s)
                        (explore-loop S* W* graph*)))))))))

    (define start (current-milliseconds))
    (explore-loop (set) (set initial) (hash))                          
  ) ; end explore  

(define (answer? s)
  (match s
    ((ko _ _ '() #f) #t)
    (_ #f)))

explore)

(define (answer-set sys)
  (let ((answer? (system-answer? sys)))
    (for/fold ((v (set))) ((s (system-states sys)))
      (if (answer? s)
          (set-add v s)
          v))))

(define (answer-value sys)
  (let* ((lattice (system-lattice sys))
         (⊥ (lattice-⊥ lattice))
         (⊔ (lattice-⊔ lattice)))
    (for/fold ((v ⊥)) ((s (answer-set sys)))
      (⊔ v (ko-v s)))))

;;

;; allocators
(define conc-alloc-counter 0)
(define conc-alloc
  (lambda _
    (set! conc-alloc-counter (add1 conc-alloc-counter))
    conc-alloc-counter))

(define (mono-alloc x _)
  x)

(define (poly-alloc x ctx)
  (cons x ctx))
;;

(define conc-kalloc (lambda (e clo rands A) (ctx (conc-alloc) clo rands A)))
(define free-kalloc (lambda (e clo rands A) (ctx e clo rands A)))

(define conc-mach (make-machine conc-lattice conc-alloc conc-kalloc #f))
(define type-mach-0 (make-machine type-lattice mono-alloc free-kalloc #t))
(define type-mach-1 (make-machine type-lattice poly-alloc free-kalloc #t)) ;TODO!!!!

(define (do-eval e mach)
  (let ((sys (mach e)))
    (if (eq? (system-exit sys) 'ok)
        (answer-value sys)
        (raise (system-msg sys)))))

(define (conc-eval e)
  (do-eval e conc-mach))
(define (type-eval-0 e)
  (do-eval e type-mach-0))
(define (type-eval-1 e)
  (do-eval e type-mach-1))

(define (state-repr s)
  (match s
    ((ev e ρ _ ι κ) (format "~a | ~a" (~a e #:max-width 20) (ctx->ctxi κ)))
    ((ko v _ ι κ) (format "~a | ~a" (~a v #:max-width 20) (ctx->ctxi κ)))))

(define (generate-dot graph name)  
  (let ((dotf (open-output-file (format "~a.dot" name) #:exists 'replace)))
    (fprintf dotf "digraph G {\n")
    (for/fold ((S (set))) (((s ts) graph))
      (let ((si (state->statei s)))
        (unless (set-member? S si)
          (fprintf dotf "~a [label=\"~a | ~a\"];\n" si si (state-repr s)))
        (for/fold ((S (set-add S si))) ((t ts))
          (match-let (((transition s*) t))
            (let ((si* (state->statei s*)))
              (unless (set-member? S si*)
                (fprintf dotf "~a [label=\"~a | ~a\"];\n" si* si* (state-repr s*)))
              (fprintf dotf "~a -> ~a;\n" si si*)
              (set-add S si*))))))
    (fprintf dotf "}")
    (close-output-port dotf)))

(define (flow-test . ens)
  (when (null? ens)
    (set! ens '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2 sat collatz rsa primtest factor nqueens)))
  (define (perform name e)
    (let* ((sys (type-mach-0 e))
           (flow-duration (system-duration sys))
           (flow-state-count (vector-length (system-states sys)))
           (flow-exit (system-exit sys))
           (flow-Ξi (system-Ξi sys))
           (flow-msg (if (eq? flow-exit 'ok) (answer-value sys) (system-msg sys))))
      (printf "~a states ~a time ~a Ξi ~a | ~a\n"
              (~a name #:min-width 12)
              (~a (if (eq? flow-exit 'ok) flow-state-count (format ">~a" flow-state-count)) #:min-width 7)
              (~a flow-duration #:min-width 7)
              (~a flow-Ξi #:min-width 4)  
              (~a flow-msg #:max-width 72))))
  (for-each (lambda (en) (perform en (eval en)))
            ens))

(define (server-flow-test)
  (parameterize ((CESK-TIMELIMIT 60))
    (apply flow-test '(fac fib fib-mut blur eta mj09 gcipd kcfa2 kcfa3 rotate loop2
                           sat collatz rsa primtest factor nqueens dderiv mceval)))); boyer))))
